/**
 * How peer sync works:
 *
 * SYncMSG: on a connection both peers send the current VV of each object they have.
 *      Also send the IDS of any state based objects.
 *
 * on a SYncMSG: peer checks objects the other peer has.
 *      ops objects: check diff, send missing ops to other peer
 *      state object: send current state
 *
 * on sync complete ():
 *      clear the message queue.
 *
 */


/**
 *
 * @param legion {Legion}
 * @param objectStore {ObjectStore}
 * @param peerConnection {PeerConnection}
 * @constructor
 */
function PeerSync(legion, objectStore, peerConnection) {
    this.legion = legion;
    this.objectStore = objectStore;
    this.peerConnection = peerConnection;

    /**
     * True when syncing is done.
     * @type {boolean}
     */
    this.isSynced = false;

    /**
     * Contains updates to be sent after sync.
     * TODO: this queue must have some parsing to eliminate duplicates and merge state propagation of the same object?
     * @type {ALQueue}
     */
    this.queueAfterSync = new ALQueue();

    /**
     * A map of all objects the other peer maintains.
     * @type {ALMap}
     */
    this.sharedObjects = new ALMap();

    var ps = this;
    this.psTimeout = setTimeout(function () {
        console.error("No PeerSync in time.", ps.legion.id, ps.peerConnection.remoteID);
    }, 5 * 1000);
}

PeerSync.prototype.send = function (message) {
    if (this.isSynced) {
        this.peerConnection.send(message);
    } else {
        this.queueAfterSync.push(message);
    }
};

PeerSync.prototype.finalize = function () {
    this.isSynced = false;
    this.peerConnection = null;
    this.queueAfterSync.clear();
    this.queueAfterSync = null;
    this.sharedObjects.clear();
    this.sharedObjects = null;
    clearTimeout(this.psTimeout);
};

/**
 * Clears the queue, sending all messages to the peer.
 */
PeerSync.prototype.clearQueue = function () {
    if (!this.isSynced) {
        console.error("Clearing queue before sync.");
    } else {
        var pop = this.queueAfterSync.pop();
        if (pop) {
            console.log("Clearing queue to: " + this.peerConnection.remoteID + ". Size of queue: " + (this.queueAfterSync.size() + 1));
        }
        while (typeof pop != "undefined") {
            this.peerConnection.send(pop);
            pop = this.queueAfterSync.pop();
        }
    }
};

/**
 * Receives from remote peer a message generated by PeerSync.handleSync.
 * @param message {...{content: {states: [], missing_ops: []}}}
 */
PeerSync.prototype.handleSyncAnswer = function (message) {
    var states = message.content.states;
    var operations = message.content.missing_ops;

    for (var j = 0; j < states.length; j++) {
        var my_state_crdt = this.objectStore.crdts.get(states[j].id);
        if (!my_state_crdt) {
            console.warn("I should not be here.");
        } else {
            my_state_crdt.stateFromNetwork(my_state_crdt.fromJSONString(states[j].state), this.peerConnection);
        }
    }
    for (var i = 0; i < operations.length; i++) {
        var my_op_crdt = this.objectStore.crdts.get(operations[i].id);
        if (!my_op_crdt) {
            console.warn("I should not be here.");
        } else {
            my_op_crdt.operationsFromNetwork(operations[i].operations, this.peerConnection);
        }
    }

    this.isSynced = true;
    this.clearQueue();
};

/**
 * Receives from remote peer a message generated by PeerSync.sync.
 * @param message {...{content: {stateObjects: [], operationObjects: []}}}
 */
PeerSync.prototype.handleSync = function (message) {
    var stateObjects = message.content.stateObjects;
    var operationObjects = message.content.operationObjects;

    var answer = {missing_ops: [], states: []};
    for (var i = 0; i < operationObjects.length; i++) {
        var my_op_crdt = this.objectStore.crdts.get(operationObjects[i].id);
        if (!my_op_crdt)
            continue;
        var my_crdts_vv = my_op_crdt.getVersionVector();
        var vvDiff = this.objectStore.versionVectorDiff(my_crdts_vv, operationObjects[i].vv);
        if (Object.keys(vvDiff.vv2.missing).length > 0) {
            answer.missing_ops.push({
                id: my_op_crdt.objectID,
                operations: my_op_crdt.getOperations(vvDiff.vv2.missing)
            });
        }
    }
    for (var j = 0; j < stateObjects.length; j++) {
        var my_state_crdt = this.objectStore.crdts.get(stateObjects[j].id);
        if (!my_state_crdt)
            continue;
        answer.states.push({id: my_state_crdt.objectID, state: my_state_crdt.toJSONString(my_state_crdt.getState())});
    }

    var ps = this;
    this.legion.generateMessage(this.objectStore.handlers.peerSyncAnswer.type, answer, function (result) {
        result.destination = ps.peerConnection.remoteID;
        ps.peerConnection.send(result);
    });
};

PeerSync.prototype.sync = function () {
    var ps = this;
    var messageContent = {stateObjects: [], operationObjects: []};

    var localKeys = this.objectStore.crdts.keys();
    for (var i = 0; i < localKeys.length; i++) {
        var crdt = this.objectStore.crdts.get(localKeys[i]);
        if (crdt.crdt.propagation == CRDT.STATE_BASED) {
            messageContent.stateObjects.push({id: crdt.objectID});
        } else if (crdt.crdt.propagation == CRDT.OP_BASED) {
            messageContent.operationObjects.push({id: crdt.objectID, vv: crdt.getVersionVector()});
        } else {
            console.error("Shit happened.")
        }
    }
    this.legion.generateMessage(this.objectStore.handlers.peerSync.type, messageContent, function (result) {
        result.destination = ps.peerConnection.remoteID;
        ps.peerConnection.send(result);
    });
};

var CRDT_LIB = {};

/**
 *
 * @param legion {Legion}
 * @constructor
 */
function ObjectStore(legion) {
    this.legion = legion;

    this.types = new ALMap();
    this.crdts = new ALMap();

    this.peerSyncs = new ALMap();

    var os = this;
    this.handlers = {
        peerSync: {
            type: "OS:PS", callback: function (message) {
                console.info(message);
                var ps = os.peerSyncs.get(message.sender);
                if (!ps) {
                    console.warn("Got OS:PS for unknown peer.");
                } else {
                    clearTimeout(ps.psTimeout);
                    ps.handleSync(message);
                }
            }
        },
        peerSyncAnswer: {
            type: "OS:PSA", callback: function (message) {
                console.info(message);
                var ps = os.peerSyncs.get(message.sender);
                if (!ps) {
                    console.warn("Got OS:PSA for unknown peer.");
                } else {
                    ps.handleSyncAnswer(message);
                }
            }
        },
        gotContentFromNetwork: {
            type: "OS:C", callback: function (message, original, connection) {
                console.info(message);
                os.gotContentFromNetwork(message, original, connection);
            }
        },
        version_vector_propagation: {
            type: "OS:VVP", callback: function (message, original, connection) {
                console.info(message);
                os.gotVVFromNetwork(message, original, connection);
            }
        }
    };

    this.serverQueue = new ALQueue();

    this.serverTimer = setInterval(function () {
        os.clearServerQueue();
    }, this.legion.options.objectOptions.serverInterval);

    this.peersQueue = new ALQueue();

    this.peersTimer = setInterval(function () {
        os.clearPeersQueue();
    }, this.legion.options.objectOptions.peerInterval);

    var peers = this.legion.overlay.getPeers();
    if (peers.length > 0) {
        console.warn("Already have peers!", peers.length);
    }
    for (var i = 0; i < peers.length; i++) {
        var p = new PeerSync(this.legion, this, peers[i]);
        this.peerSyncs.set(peers[i].remoteID, p);
        p.sync();
    }


    this.legion.messagingAPI.setHandlerFor(this.handlers.peerSync.type, this.handlers.peerSync.callback);
    this.legion.messagingAPI.setHandlerFor(this.handlers.peerSyncAnswer.type, this.handlers.peerSyncAnswer.callback);
    this.legion.messagingAPI.setHandlerFor(this.handlers.gotContentFromNetwork.type, this.handlers.gotContentFromNetwork.callback);
    //this.legion.messagingAPI.setHandlerFor(this.handlers.operations_propagation.type, this.handlers.operations_propagation.callback);
    this.legion.messagingAPI.setHandlerFor(this.handlers.version_vector_propagation.type, this.handlers.version_vector_propagation.callback);

}

/**
 * VV should ONLY be propagated between two peers.
 * @param message
 * @param original
 */
ObjectStore.prototype.gotVVFromNetwork = function (message, original) {
    var objectID = message.content.objectID;
    var hisVV = message.content.vv;

    var crdt = this.crdts.get(objectID);
    if (!crdt) {
        console.warn("Not implemented: vv for CRDT I do not have.")
    }

    var vvDiff = this.versionVectorDiff(crdt.getVersionVector(), hisVV);

    var os = this;
    if (vvDiff.vv2.missing.length > 0) {
        if (objectsDebug) {
            console.log("Peer is missing ops.");
        }
        var operations = crdt.getOperations(vvDiff.vv2.missing);
        var answer = [];
        answer.push({
            objectID: objectID,
            operations: operations
        });
        this.legion.generateMessage(this.handlers.operations_propagation.type, answer, function (result) {
            if (os.peerSyncs.contains(message.sender)) {
                result.destination = message.sender;
                var ps = os.peerSyncs.get(message.sender);
                ps.send(result);
            } else {
                os.legion.messagingAPI.sendTo(message.sender, result);
            }
        });
    }
    if (vvDiff.vv1.missing.length > 0) {
        if (objectsDebug) {
            console.log("I am missing ops.");
        }
        var request = {
            objectID: objectID,
            vv: crdt.getVersionVector()
        };
        this.legion.generateMessage(this.handlers.version_vector_propagation.type, request, function (result) {
            result.destination = message.sender;
            if (os.peerSyncs.contains(message.sender)) {
                result.destination = message.sender;
                var ps = os.peerSyncs.get(message.sender);
                ps.send(result);
            } else {
                os.legion.messagingAPI.sendTo(message.sender, result);
            }
        });
    }
};

ObjectStore.prototype.gotContentFromNetwork = function (message, original, connection) {
    switch (message.content.type) {
        case "OP":
            var objectID = message.content.msg.objectID;
            var crdt = this.crdts.get(objectID);
            if (crdt) {
                crdt.operationsFromNetwork([message.content.msg], connection);
            } else {
                console.error("Got op for no crdt", message)
            }
            break;
        case "OPLIST":
            var ops = message.content.ops;
            var crdt = this.crdts.get(message.content.objectID);
            crdt.operationsFromNetwork(ops, connection);
            break;
        case "STATE":
            var objectID = message.content.msg.objectID;
            var crdt = this.crdts.get(objectID);
            if (crdt) {
                crdt.stateFromNetwork(crdt.fromJSONString(message.content.msg.state), connection);
            } else {
                console.error("Got state for no crdt", message)
            }
            break;
    }
};

/**
 * TODO: this queue must have some parsing to eliminate duplicates and merge state propagation of the same object?
 */
ObjectStore.prototype.clearServerQueue = function () {
    if (this.serverQueue.size() > 0) {
        console.warn("Not implemented: clearServerQueue");
    }
};

/**
 * TODO: this queue must have some parsing to eliminate duplicates and merge state propagation of the same object?
 * TODO: put them messages in a super message.
 */
ObjectStore.prototype.clearPeersQueue = function () {
    var os = this;
    if (this.peersQueue.size() > 0) {
        console.log("Messages in queue: " + this.peersQueue.size());
        var pop = this.peersQueue.pop();
        while (pop) {
            (function () {
                var options = pop.options;

                const except = options.except;
                if (options.onlyTo && (typeof options.onlyTo != "string"))
                    options.onlyTo = options.onlyTo.remoteID;
                if (options.except && (typeof options.except != "string"))
                    options.except = options.except.remoteID;

                var msg = {};
                switch (pop.type) {
                    case "OP":
                        var objectID = pop.objectID;
                        var clientID = pop.clientID;
                        var operationID = pop.operationID;
                        var crdt = os.crdts.get(objectID);
                        var op = crdt.getOpFromHistory(clientID, operationID);
                        op.clientID = clientID;
                        op.objectID = objectID;
                        msg = op;
                        break;
                    case "OPLIST":
                        break;
                    case "STATE":
                        var objectID = pop.objectID;
                        var crdt = os.crdts.get(objectID);
                        var state = crdt.toJSONString(crdt.getState());
                        msg = {objectID: objectID, state: state};
                        break;
                }
                pop.msg = msg;
                if (except)
                    console.log("Sending a", pop.type, except.remoteID);
                else
                    console.log("Sending a", pop.type);
                os.legion.generateMessage(os.handlers.gotContentFromNetwork.type, pop, function (result) {
                    const onlyTo = options.onlyTo;
                    if (onlyTo) {
                        result.destination = onlyTo;
                        if (os.peerSyncs.contains(onlyTo)) {
                            result.destination = onlyTo;
                            var ps = os.peerSyncs.get(onlyTo);
                            ps.send(result);
                        } else {
                            os.legion.messagingAPI.sendTo(onlyTo, result);
                        }
                    } else if (except) {
                        os.legion.messagingAPI.broadcastMessage(result, [except, os.legion.connectionManager.serverConnection]);
                    } else {
                        os.legion.messagingAPI.broadcastMessage(result, [os.legion.connectionManager.serverConnection]);
                    }
                });
            })();

            pop = this.peersQueue.pop();
        }
    }
};

/**
 * Defines a CRDT that can later be instantiated.
 * @param crdt {crtd_type}
 */
ObjectStore.prototype.defineCRDT = function (crdt) {
    if (this.types.contains(crdt.type)) {
        console.error("Can't redefine existing CRDT.", crdt);
    } else {
        this.types.set(crdt.type, crdt);
    }
};

/**
 * Creates or obtains a CRDT.
 * @param objectID
 * @param type
 * @returns {Object}
 */
ObjectStore.prototype.get = function (objectID, type) {
    if (!this.types.contains(type)) {
        console.error("No typedef found for CRDT.", type);
    } else {
        if (this.crdts.contains(objectID)) {
            return this.crdts.get(objectID);
        } else {
            var crdt = this.types.get(type);
            var instance = new CRDT(objectID, crdt, this);
            this.crdts.set(objectID, instance);
            return instance;
        }
    }
};

/**
 *
 * @param clientID {number}
 * @param operationID {number}
 * @param options {Object}
 */
ObjectStore.prototype.propagate = function (objectID, clientID, operationID, options) {
    var queuedOP = {
        type: "OP",
        clientID: clientID,
        objectID: objectID,
        operationID: operationID,
        options: options
    };
    this.serverQueue.push(queuedOP);
    this.peersQueue.push(queuedOP);
};

/**
 *
 * @param objectID
 * @param ops
 * @param options {Object}
 */
ObjectStore.prototype.propagateAll = function (objectID, ops, options) {
    var queuedOP = {
        type: "OPLIST",
        ops: ops,
        objectID: objectID,
        options: options
    };
    this.serverQueue.push(queuedOP);
    this.peersQueue.push(queuedOP);
};

/**
 * Overlay added signalling connection.
 * @param serverConnection
 */
ObjectStore.prototype.onServerDisconnection = function (serverConnection) {
    console.warn("Not Implemented: onServerDisconnection");
    //TODO: objectsStore in charge of adding objects to objects server.
    // should sync first.
};

/**
 * Signalling connection dropped.
 * @param serverConnection
 */
ObjectStore.prototype.onServerConnection = function (serverConnection) {
    console.warn("Not Implemented: ObjectStore.onServerConnection");
    //TODO: objectsStore NO LONGER in charge of adding objects to objects server.
};

/**
 * Overlay added a peer.
 * @param peerConnection
 */
ObjectStore.prototype.onClientConnection = function (peerConnection) {
    var p = new PeerSync(this.legion, this, peerConnection);
    this.peerSyncs.set(peerConnection.remoteID, p);
    p.sync();
};

/**
 * A peer dropped the connection.
 * @param peerConnection
 */
ObjectStore.prototype.onClientDisconnection = function (peerConnection) {
    var p = this.peerSyncs.get(peerConnection.remoteID);
    this.peerSyncs.delete(peerConnection.remoteID);
    p.finalize();
};

/**
 * Returns the operations missing at each in form: {vv1:{missing:[]}, vv2:{missing:[]}}.
 * @param vv1
 * @param vv2
 * @returns {{vv1: {missing: {}}, vv2: {missing: {}}}}
 */
ObjectStore.prototype.versionVectorDiff = function (vv1, vv2) {
    var ret = {vv1: {missing: {}}, vv2: {missing: {}}};
    var keys1 = Object.keys(vv1);
    var keys2 = Object.keys(vv2);
    for (var i = 0; i < keys1.length; i++) {
        var currentKey = keys1[i];
        if (!vv2[currentKey]) {
            ret.vv2.missing[currentKey] = [];
            for (var op_i = 1; op_i <= vv1[currentKey]; op_i++) {
                ret.vv2.missing[currentKey].push(op_i);
            }
        } else if (vv2[currentKey] > vv1[currentKey]) {
            ret.vv1.missing[currentKey] = [];
            for (var op_i = vv1[currentKey] + 1; op_i <= vv2[currentKey]; op_i++) {
                ret.vv1.missing[currentKey].push(op_i);
            }
        }
    }

    for (var j = 0; j < keys2.length; j++) {
        var currentKey = keys2[i];
        if (!vv1[currentKey]) {
            ret.vv1.missing[currentKey] = [];
            for (var op_i = 1; op_i <= vv2[currentKey]; op_i++) {
                ret.vv1.missing[currentKey].push(op_i);
            }
        } else if (vv1[currentKey] > vv2[currentKey]) {
            ret.vv2.missing[currentKey] = [];
            for (var op_i = vv2[currentKey] + 1; op_i <= vv1[currentKey]; op_i++) {
                ret.vv2.missing[currentKey].push(op_i);
            }
        }
    }

    return ret;
};

/**
 *
 * @param objectID {String}
 * @param options {{onlyTo}|{except}|{all}}
 */
ObjectStore.prototype.propagateState = function (objectID, options) {
    var queuedOP = {
        type: "STATE",
        objectID: objectID,
        options: options
    };
    this.serverQueue.push(queuedOP);
    this.peersQueue.push(queuedOP);
};