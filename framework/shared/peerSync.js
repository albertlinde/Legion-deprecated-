/**
 * How peer sync works:
 *
 * SYncMSG: on a connection both peers send the current VV of each object they have.
 *      Also send the IDS of any state based objects.
 *
 * on a SYncMSG: peer checks objects the other peer has.
 *      ops objects: check diff, send missing ops to other peer
 *      state object: send current state
 *
 * on sync complete ():
 *      clear the message queue.
 *
 */
if (typeof exports != "undefined") {
    exports.PeerSync = PeerSync;

    ALMap = require('./ALMap.js');
    ALMap = ALMap.ALMap;
    ALQueue = require('./ALQueue.js');
    ALQueue = ALQueue.ALQueue;
}


/**
 *
 * @param legion {Legion}
 * @param objectStore {ObjectStore}
 * @param peerConnection {PeerConnection, ServerConnection}
 * @constructor
 */
function PeerSync(legion, objectStore, peerConnection) {
    console.log("New peerSync from " + legion.id + " to " + peerConnection.remoteID);
    this.legion = legion;
    this.objectStore = objectStore;
    this.peerConnection = peerConnection;

    /**
     * True when syncing is done.
     * @type {boolean}
     */
    this.isSynced = false;

    /**
     * Contains updates to be sent after sync.
     * @type {ALQueue}
     */
    this.queueAfterSync = new ALQueue();

    /**
     * A map of all objects the other peer maintains.
     * @type {ALMap}
     */
    this.sharedObjects = new ALMap();

    var ps = this;
    this.psTimeout = setTimeout(function () {
        console.error("No PeerSync in time.", ps.legion.id, ps.peerConnection.remoteID);
    }, 5 * 1000);
}

PeerSync.prototype.close = function () {
    this.peerConnection.close();
    this.finalize();
};

PeerSync.prototype.send = function (message) {
    if (typeof message == "object") {
        message = JSON.stringify(message);
    }
    if (this.isSynced) {
        if (this.queueAfterSync.size() == 0)
            this.peerConnection.send(message);
        else
            this.queueAfterSync.push(message);
    } else {
        this.queueAfterSync.push(message);
    }
};

PeerSync.prototype.finalize = function () {
    this.isSynced = false;
    this.peerConnection = null;
    this.queueAfterSync.clear();
    this.queueAfterSync = null;
    this.sharedObjects.clear();
    this.sharedObjects = null;
    clearTimeout(this.psTimeout);
};

/**
 * Clears the queue, sending all messages to the peer.
 */
PeerSync.prototype.clearQueue = function () {
    if (!this.isSynced) {
        console.error("Clearing queue before sync.");
    } else {
        var pop = this.queueAfterSync.pop();
        if (pop) {
            console.log("Clearing queue to: " + this.peerConnection.remoteID + ". Size of queue: " + (this.queueAfterSync.size() + 1));
        }
        while (typeof pop != "undefined") {
            this.peerConnection.send(pop);
            pop = this.queueAfterSync.pop();
        }
    }
};

/**
 * Receives from remote peer a message generated by PeerSync.handleSync.
 * @param message {...{content: {states: [], missing_ops: []}}}
 */
PeerSync.prototype.handleSyncAnswer = function (message) {
    var states = message.content.states;
    var operations = message.content.missing_ops;

    for (var j = 0; j < states.length; j++) {
        var my_state_crdt = this.objectStore.getCRDT(states[j].id, states[j].type);
        if (!my_state_crdt) {
            console.log("I should not be here.");
        } else {
            my_state_crdt.stateFromNetwork(my_state_crdt.fromJSONString(states[j].state), this.peerConnection);
        }
    }
    for (var i = 0; i < operations.length; i++) {
        var my_op_crdt = this.objectStore.getCRDT(operations[i].id, operations[i].type);
        if (!my_op_crdt) {
            console.log("I should not be here.");
        } else {
            my_op_crdt.operationsFromNetwork(operations[i].operations, this.peerConnection);
        }
    }

    clearTimeout(this.psTimeout);
    this.isSynced = true;
    this.clearQueue();
};

/**
 * Receives from remote peer a message generated by PeerSync.sync.
 * @param message {...{content: {stateObjects: [], operationObjects: []}}}
 */
PeerSync.prototype.handleSync = function (message) {
    var stateObjects = message.content.stateObjects;
    var operationObjects = message.content.operationObjects;

    var answer = {missing_ops: [], states: []};
    for (var i = 0; i < operationObjects.length; i++) {
        var my_op_crdt = this.objectStore.getCRDT(operationObjects[i].id, operationObjects[i].type);
        if (!my_op_crdt)
            continue;
        var my_crdts_vv = my_op_crdt.getVersionVector();
        var vvDiff = my_op_crdt.versionVectorDiff(my_crdts_vv, operationObjects[i].vv);
        if (Object.keys(vvDiff.vv2.missing).length > 0) {
            answer.missing_ops.push({
                id: my_op_crdt.objectID,
                operations: my_op_crdt.getOperations(vvDiff.vv2.missing)
            });
        }
    }
    for (var j = 0; j < stateObjects.length; j++) {
        var my_state_crdt = this.objectStore.getCRDT(stateObjects[j].id, stateObjects[j].type);
        if (!my_state_crdt)
            continue;
        answer.states.push({id: my_state_crdt.objectID, state: my_state_crdt.toJSONString(my_state_crdt.getState())});
    }

    var ps = this;
    this.legion.generateMessage(this.objectStore.handlers.peerSyncAnswer.type, answer, function (result) {
        result.destination = ps.peerConnection.remoteID;
        ps.peerConnection.send(JSON.stringify(result));
    });
};

PeerSync.prototype.sync = function () {
    var ps = this;
    var messageContent = {stateObjects: [], operationObjects: []};

    var localKeys = this.objectStore.crdts.keys();
    for (var i = 0; i < localKeys.length; i++) {
        var crdt = this.objectStore.getCRDT(localKeys[i]);
        if (crdt.crdt.propagation == CRDT.STATE_BASED) {
            messageContent.stateObjects.push({id: crdt.objectID, type: crdt.crdt.type});
        } else if (crdt.crdt.propagation == CRDT.OP_BASED) {
            messageContent.operationObjects.push({
                id: crdt.objectID,
                vv: crdt.getVersionVector(),
                type: crdt.crdt.type
            });
        } else if (crdt.crdt.propagation == CRDT.DELTA_BASED) {
            console.warn("Not implemented yet.");
        } else {
            console.error("Shit happened.")
        }
    }
    this.legion.generateMessage(this.objectStore.handlers.peerSync.type, messageContent, function (result) {
        result.destination = ps.peerConnection.remoteID;
        if (typeof CRDT_Database != "undefined") {
            console.log("Send " + result.type + " to " + ps.peerConnection.remoteID + " s: " + result.sender);
        }
        ps.peerConnection.send(JSON.stringify(result));
    });
};